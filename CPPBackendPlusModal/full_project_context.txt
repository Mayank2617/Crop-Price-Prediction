GENSQUAD FULL STACK CONTEXT
===========================

1. PROJECT STRUCTURE:
=====================
./
    .dockerignore
    .env
    .gitignore
    all_states_weather_data.csv
    app copy.py
    app.py
    bash.exe.stackdump
    crop.csv
    crop_advisory.py
    crop_prediction.ipynb
    crop_prediction_preprocessing2.csv
    crop_preprocessing.csv
    Dockerfile
    final_data.csv
    final_priceprediction.ipynb
    final_priceprediction.py
    maxcrop_price_model.joblib
    maxpriceprediction.ipynb
    midcrop_price_model.joblib
    midpriceprediction.ipynb
    mincrop_price_model.joblib
    minpriceprediction.ipynb
    nixpacks.toml
    package.json
    predict_wrapper.py
    price_prediction.csv
    Procfile
    requirements.txt
    server.js
    soildata.csv
    weather.csv
    .ipynb_checkpoints/
        final_data-checkpoint.csv
        final_priceprediction-checkpoint.ipynb
    controllers/
        advisoryController.js
        authController.js
        predictController.js
    middleware/
        authMiddleware.js
    models/
        User.js
    routes/
        advisoryRoutes.js
        authRoutes.js
        predictRoute.js
        protectedRoutes.js


2. FILE CONTENTS:
=================


--- START OF FILE: .\.env ---
MONGO_URI=mongodb+srv://mayankthesahu:QK60HkWhPNQMoC4g@croppriceprediction.9uuvtyl.mongodb.net/?retryWrites=true&w=majority&appName=croppriceprediction
JWT_SECRET=253e40ec9c932b7ee0393c9dc19368fcf0ed79cb62ef176feaa4135421dd8e05387977462527fc9c868b7c95ef3cbfe122458df57a49a643c81104a3d3fc741f
PORT=5000
--- END OF FILE: .\.env ---


--- START OF FILE: .\package.json ---
{
  "name": "cppbackend",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "postinstall": "apt-get update && apt-get install -y python3 python3-pip",
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.10.0"
  }
}
--- END OF FILE: .\package.json ---


--- START OF FILE: .\server.js ---
require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const authRoutes = require("./routes/authRoutes");
const protectedRoutes = require("./routes/protectedRoutes");
const predictRoutes = require('./routes/predictRoute');
const advisoryRoutes = require('./routes/advisoryRoutes');
const { exec } = require('child_process');


const app = express();

// Middleware
app.use(cors());
app.use(express.json()); // Allows us to accept JSON data


// Connect to MongoDB
mongoose.connect(process.env.MONGO_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
}).then(() => console.log('MongoDB Connected'))
    .catch(err => console.log(err));

// Routes

app.use("/api/auth", authRoutes);
app.use("/api/protected", protectedRoutes);
app.use('/api/predict', predictRoutes);
app.use('/api/advisory', advisoryRoutes);



app.get("/", (req, res) => {
    res.send("Backend is running...");
    exec('python3 --version', (error, stdout, stderr) => {
        if (error) {
          console.error('Python not found:', error);
        } else {
          console.log('Python version:', stdout);
        }
      });
});



const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

--- END OF FILE: .\server.js ---


--- START OF FILE: .\controllers\advisoryController.js ---
const { spawn } = require("child_process");
const path = require("path");

const runModelPrediction = (req, res) => {
  const { state, soil, month } = req.body;


  const pythonPath = path.join(__dirname,'..', 'crop_advisory.py');
  console.log("ðŸš€ Running script at:", pythonPath);

  const pythonProcess = spawn("python3", [pythonPath, state, soil, month]);
  
  let result = "";
  let error = "";

  pythonProcess.stdout.on("data", (data) => {
    result += data.toString();
  });

  pythonProcess.stderr.on("data", (data) => {
    error += data.toString();
  });

  pythonProcess.on("close", (code) => {
    if (code !== 0) {
      return res.status(500).json({ error: error || "Python script failed" });
    }

    try {
      const jsonResult = JSON.parse(result);
      res.json(jsonResult);
    } catch (e) {
      res.status(500).json({ error: "Failed to parse Python output", raw: result });
    }
  });
};

module.exports = { runModelPrediction };

--- END OF FILE: .\controllers\advisoryController.js ---


--- START OF FILE: .\controllers\authController.js ---
const User = require("../models/User");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");

const register = async (req, res) => {
    try {
        const { firstName, middleName, lastName, phone, email, profession, password } = req.body;

        // Hash password
        const hashedPassword = await bcrypt.hash(password, 10);

        // Create new user
        const newUser = new User({
            firstName,
            middleName,
            lastName,
            phone,
            email,
            profession,
            password: hashedPassword
        });

        // Save user to DB
        await newUser.save();

        res.status(201).json({ message: "User registered successfully" });

    } catch (error) {
        if (error.code === 11000) {
            if (error.keyPattern.phone) {
                return res.status(400).json({ message: "Phone number already registered" });
            }
            if (error.keyPattern.email) {
                return res.status(400).json({ message: "Email already exists" });
            }
        }

        res.status(500).json({ message: "Server error", error });
    }
};

// Handle login logic (as part of the controller)
const loginUser = async (req, res) => {
    const { phone, password } = req.body;
    try {
        const user = await User.findOne({ phone });
        if (!user) {
            return res.status(400).json({ message: "User not found!" });
        }

        const isMatch = await bcrypt.compare(password, user.password);
        if (!isMatch) {
            return res.status(400).json({ message: "Invalid credentials!" });
        }

        const token = jwt.sign(
            { userId: user._id, phone: user.phone },
            process.env.JWT_SECRET,
            { expiresIn: "1h" }
        );

        res.status(200).json({ message: "Login successful!", token });

    } catch (error) {
        console.error(error);
        res.status(500).json({ message: "Server error" });
    }
};


module.exports = { register,loginUser  };

--- END OF FILE: .\controllers\authController.js ---


--- START OF FILE: .\controllers\predictController.js ---
const { spawn } = require('child_process');
const path = require('path');

exports.runModelPrediction = (req, res) => {
  const inputData = JSON.stringify(req.body);
  const scriptPath = path.join(__dirname,'..','final_priceprediction.py');

  const pythonProcess = spawn('python3', [scriptPath, inputData]);

  let result = '';
  let error = '';

  pythonProcess.stdout.on('data', (data) => {
    result += data.toString();
  });

  pythonProcess.stderr.on('data', (data) => {
    error += data.toString();
  });

  pythonProcess.on('close', (code) => {
    if (code !== 0) {
      console.error('Python script error:', error); // ðŸ”¥ LOGGING ERROR
      return res.status(500).json({ error: 'Prediction failed', details: error });
    }

    try {
      const parsed = JSON.parse(result); // if your script returns JSON
      res.json(parsed);
    } catch (e) {
      console.error('Failed to parse model output:', result);
      res.status(500).json({ error: 'Invalid model output', raw: result });
    }
  });
};

--- END OF FILE: .\controllers\predictController.js ---


--- START OF FILE: .\middleware\authMiddleware.js ---
const jwt = require("jsonwebtoken");

const authMiddleware = (req, res, next) => {
    const token = req.header("Authorization");

    // Check if token exists
    if (!token) {
        return res.status(401).json({ message: "Access denied. No token provided." });
    }

    try {
        // Verify the token
        const decoded = jwt.verify(token.replace("Bearer ", ""), process.env.JWT_SECRET);
        req.user = decoded; // Attach user info to request object
        next(); // Move to next middleware
    } catch (error) {
        res.status(400).json({ message: "Invalid token" });
    }
    
};

module.exports = authMiddleware;

--- END OF FILE: .\middleware\authMiddleware.js ---


--- START OF FILE: .\models\User.js ---
const mongoose = require("mongoose");

const UserSchema = new mongoose.Schema({
    firstName: { type: String, required: true },
    middleName: { type: String, required: false }, // Optional field
    lastName: { type: String, required: true },
    phone: { type: String, required: true, unique: true },
    email: { type: String, required: true, unique: true },
    profession: { type: String, required: true },
    password: { type: String, required: true },
}, { timestamps: true });

module.exports = mongoose.model("User", UserSchema);

--- END OF FILE: .\models\User.js ---


--- START OF FILE: .\routes\advisoryRoutes.js ---
const express = require('express');
const router = express.Router();
const { runModelPrediction } = require('../controllers/advisoryController');

// Route: POST /api/advisory
router.post('/', runModelPrediction);

module.exports = router;

--- END OF FILE: .\routes\advisoryRoutes.js ---


--- START OF FILE: .\routes\authRoutes.js ---
const express = require("express");
const { register } = require("../controllers/authController");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const User = require("../models/User");


const router = express.Router();
router.post("/register", register);
router.post("/login", async (req, res) => {
    const { phone, password } = req.body;

    try {
        // 1. Find the user by phone number
        const user = await User.findOne({ phone });
        if (!user) {
            return res.status(400).json({ message: "User not found!" });
        }

        // 2. Check if the password matches
        const isMatch = await bcrypt.compare(password, user.password);
        if (!isMatch) {
            return res.status(400).json({ message: "Invalid credentials!" });
        }

        // 3. Generate a JWT token
        const token = jwt.sign(
            { userId: user._id, phone: user.phone },
            process.env.JWT_SECRET,
            { expiresIn: "1h" }
        );

        res.status(200).json({ message: "Login successful!", token });

    } catch (error) {
        console.error(error);
        res.status(500).json({ message: "Server error" });
    }
});
module.exports = router;

--- END OF FILE: .\routes\authRoutes.js ---


--- START OF FILE: .\routes\predictRoute.js ---
const express = require('express');
const router = express.Router();
const { runModelPrediction } = require('../controllers/predictController');

// Route: POST /api/predict
router.post('/', runModelPrediction);

module.exports = router;

--- END OF FILE: .\routes\predictRoute.js ---


--- START OF FILE: .\routes\protectedRoutes.js ---
const express = require("express");
const authMiddleware = require("../middleware/authMiddleware");

const router = express.Router();

// Protected route example
router.get("/dashboard", authMiddleware, (req, res) => {
    res.json({ message: `Welcome, user ${req.user.id}! You have accessed a protected route.` });
});

module.exports = router;

--- END OF FILE: .\routes\protectedRoutes.js ---
